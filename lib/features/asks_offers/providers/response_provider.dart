import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:nostr_sdk/nostr_sdk.dart';
import 'package:nostrmo/main.dart'; // Import main to access global nostr
import '../models/response_model.dart';

final responseProvider =
    StateNotifierProvider<ResponseNotifier, AsyncValue<List<ResponseModel>>>((ref) {
  return ResponseNotifier(ref);
});

class ResponseNotifier extends StateNotifier<AsyncValue<List<ResponseModel>>> {
  final Ref ref;
  String? _subscriptionId;
  String? _currentListingEventId;

  ResponseNotifier(this.ref) : super(const AsyncValue.loading());

  final Map<String, ResponseModel> _latestResponses = {}; // Track latest version by (pubkey, d)

  void _handleSubscriptionEvent(Event event) {
    handleEvent(event);
    // Update state when new events arrive
    state = AsyncValue.data(_latestResponses.values.toList()..sort((a, b) => b.createdAt.compareTo(a.createdAt)));
  }

  Future<void> loadResponses({String? listingEventId}) async {
    if (nostr == null) {
      state = AsyncValue.error('Nostr client not initialized', StackTrace.current);
      return;
    }
    
    try {
      state = const AsyncValue.loading();
      _latestResponses.clear(); // Clear previous responses
      _currentListingEventId = listingEventId;

      // Create filter for kind 31112 (response events)
      final filter = Filter(kinds: [31112]);
      
      // If listing event ID is provided, filter responses for that listing
      if (listingEventId != null) {
        filter.e = [listingEventId];
      }

      // Cancel previous subscription if exists
      if (_subscriptionId != null) {
        try {
          nostr!.unsubscribe(_subscriptionId!);
        } catch (e) {
          // Ignore errors when unsubscribing
        }
      }

      // Get recent responses
      List<Event> initialEvents = [];
      try {
        initialEvents = await nostr!.queryEvents([filter.toJson()]);
      } catch (e) {
        // Log error but continue with empty list
      }
      
      for (final event in initialEvents) {
        handleEvent(event);
      }
      
      // Update state after initial load
      state = AsyncValue.data(_latestResponses.values.toList()..sort((a, b) => b.createdAt.compareTo(a.createdAt)));

      // Subscribe to future events
      _subscriptionId = "responses_${DateTime.now().millisecondsSinceEpoch}";
      
      nostr!.subscribe(
        [filter.toJson()],
        _handleSubscriptionEvent,
        id: _subscriptionId,
      );

    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  Future<void> createResponse({
    required String listingEventId,
    required String listingPubkey,
    required String listingD,
    required ResponseType responseType,
    required String content,
    String? price,
    String? availability,
    String? location,
    String? paymentInfo,
  }) async {
    if (nostr == null) {
      throw Exception('Nostr client not initialized');
    }
    
    try {
      final pubkey = nostr!.publicKey;
      final d = DateTime.now().millisecondsSinceEpoch.toString(); // Unique identifier
      final now = DateTime.now();
      
      final response = ResponseModel(
        id: '', // ID will be generated by signing
        pubkey: pubkey,
        d: d,
        listingEventId: listingEventId,
        listingPubkey: listingPubkey,
        listingD: listingD,
        responseType: responseType,
        status: ResponseStatus.pending,
        content: content,
        createdAt: now,
        price: price,
        availability: availability,
        location: location,
        paymentInfo: paymentInfo,
      );

      Event eventToPublish = response.toEvent();
      // Update createdAt for the event itself before signing
      final updatedCreatedAt = now.millisecondsSinceEpoch ~/ 1000;
      eventToPublish.createdAt = updatedCreatedAt;
      
      // Sign the event
      nostr!.signEvent(eventToPublish);
      
      // Create final model with the actual event ID
      final finalResponse = response.copyWith(id: eventToPublish.id);
      
      // Send the event to relays
      await nostr!.sendEvent(eventToPublish);

      // Update local state immediately
      _updateResponse(finalResponse);

    } catch (error, stackTrace) {
      if (state is! AsyncError) {
        state = AsyncValue.error(error, stackTrace);
      }
      // Rethrow to signal failure upstream
      rethrow;
    }
  }

  Future<void> updateResponse(ResponseModel response) async {
    if (nostr == null) {
      throw Exception('Nostr client not initialized');
    }
    
    try {
      // Ensure the createdAt is newer for the replacement event
      final now = DateTime.now();
      final updatedResponse = response.copyWith(createdAt: now);

      Event eventToPublish = updatedResponse.toEvent();
      // Update createdAt for the event itself before signing
      final updatedCreatedAt = now.millisecondsSinceEpoch ~/ 1000;
      eventToPublish.createdAt = updatedCreatedAt;
      
      // Sign the event
      nostr!.signEvent(eventToPublish);

      // Update the ID in the model if needed
      final finalResponse = updatedResponse.copyWith(id: eventToPublish.id);

      // Send the event to relays
      await nostr!.sendEvent(eventToPublish);
      
      // Update local state
      _updateResponse(finalResponse);

    } catch (error, stackTrace) {
      if (state is! AsyncError) {
        state = AsyncValue.error(error, stackTrace);
      }
      // Rethrow to signal failure upstream
      rethrow;
    }
  }

  // Process incoming events
  void handleEvent(Event event) {
    if (event.kind == 31112) {
      final response = ResponseModel.fromEvent(event);
      
      // Only include responses for the current listing if a listing ID is set
      if (_currentListingEventId == null || response.listingEventId == _currentListingEventId) {
        _updateResponse(response);
      }
    }
  }

  void _updateResponse(ResponseModel response) {
    final key = '${response.pubkey}:${response.d}';
    final currentResponse = _latestResponses[key];

    // NIP-33 logic: Only update if this is a newer version
    if (currentResponse == null ||
        response.createdAt.isAfter(currentResponse.createdAt)) {
      _latestResponses[key] = response;

      // Update state with all current responses, sorted by creation date
      state = AsyncValue.data(_latestResponses.values.toList()
        ..sort((a, b) => b.createdAt.compareTo(a.createdAt)));
    }
  }

  List<ResponseModel> filterResponses({
    ResponseType? type,
    ResponseStatus? status,
    String? searchQuery,
  }) {
    if (!state.hasValue || state.value == null) return [];

    return state.value!.where((response) {
      // Filter by type
      if (type != null && response.responseType != type) return false;
      
      // Filter by status
      if (status != null && response.status != status) return false;
      
      // Filter by search query
      if (searchQuery != null && searchQuery.isNotEmpty) {
        final query = searchQuery.toLowerCase();
        return response.content.toLowerCase().contains(query);
      }
      
      // If no filters match, include the response
      return true;
    }).toList();
  }

  @override
  void dispose() {
    if (_subscriptionId != null && nostr != null) {
      try {
        nostr!.unsubscribe(_subscriptionId!);
      } catch (_) {
        // Ignore errors when unsubscribing during dispose
      }
    }
    super.dispose();
  }
}